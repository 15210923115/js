// 核心：A.call(this, ...args)
// 这种方式是通过在子类的构造函数中调用父类的构造函数来实现的，这一种方法解决了创建子类实例时不能向父类构造函数传递参数的缺点，
// 但是它存在的一个问题就是无法实现函数方法的复用，并且父类型原型定义的方法子类型也没有办法访问到。

/**
    借用构造函数继承解决的问题：
        1.实现在创建子类的实例时向父类构造函数传参，解决了原型链继承无法解决的这个问题。
 */

/**
    借用构造函数继承的缺陷：
        1.无法实现函数方法的复用，并且父类型原型定义的方法子类型也没有办法继承。
 */

function A(name) {
    this.arr = [0];
    this.name = name;
}
A.prototype.list = [0];

function B(age, ...args) {
    A.call(this, ...args);// 借用构造函数实现继承，可以实现在创建子类的实例时向父类构造函数传参，解决了原型链继承无法解决的这个问题。
    this.age = age;
}

B.prototype.info = function(){
    console.log(this.name + this.age);
}

var b1 = new B(10, 'yy');
var b2 = new B(20, 'ng');
b1.info();// yy10
b2.info();// ng20

b1.arr.push(1);

console.log(b1.arr);
// [ 0, 1 ]
console.log(b2.arr);
// [ 0 ] 可以看到，b1修改了属性arr的值，并没有影响到b2里的arr，因此借用构造函数的方式，可以解决原型链继承时包含引用类型值的问题。（该解释，仅限于父类的构造函数里的私有属性包含引用类型值，也就是说在进行原型链继承的时候有一步代码是B.prototype = new A()，这一步的new A()可能会产生引用类型值，如果把这个引用类型值赋值给了B.prototype，那么所有B类型的对象实例就会共享该引用类型值，从而产生互相干扰的问题，因为修改的都是同一个引用类型值。但是当使用借用构造函数继承的时候，就不存在该问题了，但是借用构造函数继承，无法复用函数，这是个大问题）




