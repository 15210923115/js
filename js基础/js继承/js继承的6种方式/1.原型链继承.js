// 核心：B.prototype = new A();

/**
    原型链继承解决的问题：
        1.可以实现函数的复用，也就是可以继承父类原型上的方法和属性
 */
/**
    原型链继承的缺陷：
        1.如果父类实例中的属性值包含了引用类型，那么子类实例会共享这一个属性，且由于这个属性值是引用类型，如果有一个子类实例修改了引用类型的值，那么其它的子类实例的相应属性也会跟着受影响。
        （这个问题，就是包含引用类型值的原型属性会被所有的实例共享，如果有一个实例修改了引用类型的值，那么其它的实例也会跟着受影响。）
        2.在创建子类的实例时，无法向父类的构造函数中传递参数。
    
 */


function A(name) {
    this.arr = [0];
    this.name = name;
}
A.prototype.list = [0];

function B() {}

B.prototype = new A();// 原型链继承的问题在这里：这一步的new A()可能会产生引用类型值，如果把这个引用类型值赋值给了B.prototype，那么所有B类型的对象实例就会共享该引用类型值，从而产生互相干扰的问题，因为修改的都是同一个引用类型值。

var b1 = new B();// 原型链继承的另一个问题在这里：创建子类的实例时，无法向父类的构造函数传参，借用构造函数继承的方式，可以解决此问题。
var b2 = new B();

b1.arr.push(1);
b1.list.push(1);

console.log(b1.arr, b2.arr);// [ 0, 1 ] [ 0, 1 ] b2.arr受到了b1的影响
console.log(b1.list, b2.list);// [ 0, 1 ] [ 0, 1 ] b2.list受到了b1的影响



