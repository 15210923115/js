## 进程 线程
- cpu分配资源的最小单位是进程，同一时间内，单个cpu只能运行一个进程。（时间片轮转的算法，速度非常快，所以看起多个进程好像是同时运行的）
- cpu调度任务的最小单位是线程，一个进程里包含着多个线程。

## 浏览器的进程（浏览器是多进程的）
- 每一个页卡，都是一个进程（保证每个页卡互补影响）。因为进程之间都是相互独立的，一个进程挂了，不会影响别的进程。
- 浏览器也有一个主进程（用户界面、控制台、地址栏搜索框、前进、后退等等，都放到一个进程里去了）
- 代码里，最关心的是渲染进程。每个页卡里，都有一个渲染进程（浏览器内核）
- 网络进程（处理网络请求）
- GPU进程 3d绘制
- 第三方的浏览器插件的进程，每个插件都是一个进程

## 渲染进程（包含着多个线程）js中的主线程 是单线程的
- GUI渲染线程（渲染页面的）
- js引擎线程 它和页面渲染线程是互斥的（如果是同步进行的，可能会发现js线程更新页面，那么页面渲染线程也要跟着渲染，这样就乱套了，肯定是js更新之后再渲染，或者渲染完成之后，再执行js更新数据，然后再去渲染）
- 事件触发线程 也是一个独立的线程 eventloop
- js中的事件，例如click、setTimeout、ajax 也是一个独立的线程

## 宏任务 微任务
- 宏任务 宿主环境提供的异步方法 都是宏任务 script ui 渲染 （浏览器自带的、天生就有的）
- 微任务 语言标准提供的 promise、mutationObserver

宏任务放置的时机是 当ajax成功的时候、定时器成功的时候、点击按钮的时候 -> 将对应的回调放到宏任务队列中

微任务放置的时机是 并不需要等待什么成功，它只要调用 像promise、mutationObserver 就直接将回调放到微任务队列中

ui渲染的时机是在下一个宏任务 执行之前执行

代码是怎么执行的：默认先执行 script脚本中的代码（js引擎中的代码，这个是宏任务） 执行完之后 -> 会清空微任务（就是把所有的微任务全部执行完） -> 渲染页面 -> 取出一个宏任务执行（并不是取出所有的），执行完毕之后 -> 会再次清空微任务。。。依次循环。。。

微任务和宏任务的存储结构都是队列