# 浏览器渲染原理

## 一、进程与线程

* 进程是操作系统资源分配的最小单位，进程中包含线程。
* 线程是操作系统任务调度的最小单位，线程是有进程所管理的。
* 为了提升浏览器的稳定性和安全性，浏览器采用了多进程模型。

### 1. 浏览器中的5个进程

![](./浏览器多进程模型.jpg)

* 浏览器进程：负责界面显示、用户交互、子进程管理、提供存储等。
* 渲染进程：每个页卡都有单独的渲染进程，核心用于渲染页面。
* 网络进程：主要处理网络资源加载（.html、.css、.js等）。
* GPU进程：3d绘制，提高性能。
* 插件进程：chrome中安装的一些插件。

其中，渲染进程是我们最关心的的进程，它包含了以下3个主要的线程：
* GUI渲染线程。
* js引擎线程。
* 事件触发线程。


## 二、从输入URL到浏览器显示页面发生了什么？

### 从浏览器进程的角度分析

1. 首先，用户在地址栏里输入内容，浏览器会先看用户输入的是关键字还是URL？如果是关键字，则浏览器会根据默认的搜索引擎生成URL地址，然后才开始导航。如果不是关键字，而是URL地址，则直接进行导航。（这一步操作是在浏览器进程里进行的）

2. 浏览器会准备一个渲染进程，用于渲染页面。

3. 通过网络进程加载资源，将加载的资源交给渲染进程来处理。

4. 渲染完毕，并显示页面。

上面的4个过程，包含的几个进程间的通信是通过IPC进行的。包括Node.js，它里面的进程通信也是通过IPC进行的。这个4个过程是从浏览器进程的角度回答的，比较浅，面试的时候大多都是问请求的过程发生了什么，下面将从这方面来回答从输入URL到浏览器显示页面到底发生了什么。

### 从请求的过程的角度分析

说到请求过程，就要提到网络的七层参考模型`OSI协议层次结构`（物、数、网、传、会、表、应），分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。一般会把会话层、表示层和应用层合并为一层，统称为应用层。HTTP协议就是应用层的协议。TCP位于传输层，HTTP主要是基于TCP协议进程传输的。网络层主要就是我们熟知的IP协议。通常还会把物理层和数据链路层合并为网络访问层，常见的就是双绞线、电缆、光纤等。

> OSI 协议层次结构：  
> 
> 应用层  
> 表示层  
> 会话层  
> 传输层  
> 网络层  
> 数据链路层  
> 物理层  

所以，真实情况下，我们会把七层的OSI参考模型简化为四层的`TCP/IP 协议层次结构`（网、网、传、应），分别是网络访问层、网际层（IP协议）、传输层（TCP协议）和应用层（HTTP协议）。因特网使用的就是该参考模型。

> TCP/IP 协议层次结构：  
> 
> 应用层（HTTP、UDP）  
> 传输层（TCP）  
> 网际层（IP）  
> 网络访问层

现在，我们主要从`TCP/IP 协议层次结构`来分析网络请求的整个过程。

1.地址栏输入URL地址（域名、网址）。

2.输入完域名之后，不会直接去请求，而是先去查看当前的这个网址有没有被访问过，这时候就会去查找缓存。如果有缓存，且缓存没有过期的话，就返回缓存的内容，否则就去请求。

3.接着第2步，如果没有缓存且缓存过期的话，就会通过域名去请求对方的服务器。此时会先看域名是否被解析过，如果没有解析过，就将域名解析成IP地址。此时就需要DNS协议登场，DNS协议会将域名解析成IP地址（域名只是我们方便记忆地址的一个工具，IP地址才真正记录了服务器的地址）。DNS主要做了一个映射表，把我们的域名和IP地址做了一个映射，它只是一个分布式的数据库，那我们就可以使用DNS把域名解析成一个IP地址了。

但是有个需要注意的地方，DNS的域名解析是基于UDP协议的。为什么它是基于UDP，而不是TCP呢？因为我们再解析的过程中，涉及到服务器的查找，我们的服务有一级域名和二级域名，它会迭代去查找，如果使用TCP去传输的话，每经过一个域名服务器，它就需要三次握手和四次挥手，这很浪费时间。UDP就没有三次握手和四次挥手，它是直接发送数据包，然后确认就OK了，速度上极快。TCP（数据分段传输）的好处是安全可靠，UDP（整个数据包一次性传输）是可能会有丢包的情况，我们当然是希望安全可靠最好，但是对于浏览器来说，查个域名，为了速度，肯定会采用UDP，而且如果丢包了，浏览器可以重发，速度很快。

经过DNS协议的域名查找服务之后，我们就可以得到域名对应服务的真正IP地址了，但是我们光有IP地址还不行，还要有服务的端口号Port，IP地址加上端口号Port，才能找到真正的服务。IP地址可以找到服务所在的机器，然后再根据端口号Port就可以在机器上找到真正的服务了。

4.经过DNS域名服务器查找到真正的IP地址后，就可以使用IP+Port找到服务所在的位置，就可以向服务发送请求了。此时，如果请求采用的是HTTPS协议的话，这时还会有SSL安全加密的过程，保证我们的数据是经过加密后经过加密通道安全传输的。

通过截图内容可以看到，`Connection Start`里的`Initial connection`和`SSL`，这两个大致是在同一时间段内进行的，也就是说，如果发现是HTTPS请求，在建立TCP连接通道的时候，会同步进行SSL协商的建立。

5.此时，我们使用IP开始寻址，找到服务器后，并不会立马把数据发过去，而是排队等待，因为我们的域名下可能有多个请求，我们同一个域名在HTTP1.1里有限制，就是最多可以建立6个HTTP连接，也就是说，在同一时刻，最多可以发送6个HTTP请求。

6.HTTP请求排完队之后，就开始发送HTTP请求，但是我们的HTTP请求是通过TCP传输的，因此要先让TCP创建连接，此时就会有三次握手，浏览器和服务器的TCP连接通道创建好之后，就可以使用TCP传输HTTP数据包了。这里还有一个延时，就是服务器连接的Stalled过程，这个过程，有可能会发生代理连接、TCP复用等操作，处理完之后，才去发送HTTP数据包了。

7.但是我们的数据包内容可能很大，不是一口气就能传完的，此时需要拆分成一个个的数据包，按照顺序，将数据包可靠、有序地传输给服务端，服务器收到数据包之后，会将数据包进行重新整合，服务器就获取到客户端传输过阿里的数据了。

HTTP请求的过程中，分为请求行、请求头和请求体。

从HTTP1.1开始，在发送数据的过程中，TCP连接默认是不会断开的（keep-alive），是为了下次传输数据时，可以复用上次创建好的TCP连接通道，省去了建立连接的时间。

8.服务器收到数据后，解析请求行、请求头和请求体，服务器处理完请求的内容之后，会给浏览器一个响应，有对应的响应行、响应头和响应体。这里面有一个状态码的概念，服务器可以自己去设置状态码。其中比较重要有301和302。

9.服务器返回301（永久重定向）、302状态码（临时重定向），会进行重定向操作。如果重定向了，那么浏览器和服务器之间又会重新进行DNS域名查找、IP寻址、建立TCP连接（传输HTTP数据包）、解析请求内容、服务端处理逻辑，最后服务器再次给客户端响应新的内容，那么这个过程很耗时，因此，我们再代码里，如果有些链接已经被重定向了，那我们尽量使用重定向后的链接，不要使用旧的链接了，这样会避免一次重定向的发生，减少服务请求和响应的时间，提高性能，提升用户体验。

还有304状态码，如果服务器返回了304，那么浏览器就收到之后，就会查询浏览器缓存，将缓存的结果返回给前端的接口调用。

Chrome浏览器开发者工具Network窗口下，Timing中显示资源在整个请求生命周期过程中各部分花费的时间。

![](./Timing各参数.jpg)
各个字段的具体解释，可以查看当前目录下的`./Timing各参数.md`文档。




### 1. 浏览器进程的相互调用
### 2. URL请求过程
### 3. HTTP发展历程

http://www.52im.net/thread-2680-1-1.html

#### （1）HTTP0.9 

只能传输html文本字符，没有请求头和响应头。

#### （2）HTTP1.0 

提供了http的header，可根据header的不同来处理不同的资源。一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。

#### （3）HTTP1.1 默认开启了keep-alive以维持TCP持久连接，可以在一个TCP连接上先后传输不同的http请求，提供了链路复用。

但是存在一个问题：单个 TCP 连接在同一时刻只能处理一个请求。

为了解决这个问题，HTTP1.1规定了Pipelining来试题解决这个问题，一个域名在同一时间下最多可以建立6个TCP连接。但是这个功能在浏览器中默认是关闭的。

先来看一下 Pipelining 是什么，RFC 2616 中规定了：一个支持持久连接的客户端可以在一个连接中发送多个请求（不需要等待任意请求的响应）。收到请求的服务器必须按照请求收到的顺序发送响应。

HTTP1.1还存在Head-of-line Blocking 连接头阻塞的问题：在建立起一个 TCP 连接之后，假设客户端在这个连接连续向服务器发送了几个请求。按照标准，服务器应该按照收到请求的顺序返回结果，假设服务器在处理首个请求时花费了大量时间，那么后面所有的请求都需要等着首个请求结束才能响应。

#### （4）HTTP2.0 

提供了 Multiplexing 多路传输特性，可以在一个 TCP 连接中同时完成多个 HTTP 请求。

在 HTTP/1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。
在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。

#### （5）HTTP3.0 

解决了连接头阻塞的问题，不再基于TCP，而是采用了UDP，并且在UDP的上一层加了一个QUIC协议。

HTTP3.0还存在很多问题，目前还没有大范围使用。

### 4. 渲染流程

## 三、模拟请求->渲染流程
### 1. 基于TCP发送HTTP请求
TCP的传输是字节流的形式
### 2. 解析响应结果
### 3. 解析HTML
### 4. 解析CSS
### 5. 计算样式
### 6. 布局绘制

## 四、LightHouse使用

## 五、Performance API

## 六、网络优化策略
